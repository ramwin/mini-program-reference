** Xiang Wang @ 2018-04-11 10:32:41 **


**自定义组件**
* [小程序文档](./README.md)
* [官网](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

### 创建自定义组件
1. page.json
    ```
    {
        "usingComponents": {
            "tag-name": "component/path"  # tag里面不能有数字和大写
        }
    }
    ```
2. component.js
    ```
    Component({
        properties: {
            innerText: {
                type: String,
                value: "default value",
            }
        }
    })
    ```

* 使用自定义组件
设置`.json`文件
```
{
 "usingComponents": {
   "component-tag-name": "path/to/component"
 }
}
```

### 组件模板和样式
#### 组件模板(待续)
#### 组件样式
* 外部样式类
在外面调用组件的时候可以传递class

* 全局样式类
组件内部可以使用全局样式
```
Component({
    externalClasses: ['my-class'],  # 外部拓展的样式
    options: {
        addGlobalClass: true,
    }
})
```

### Component构造器
* #### properties 外部传入的属性
```
Component({
  properties: {
    myProperty: {
      type: String,  // 可以是String, Number, Boolean, Object, Array, null(任意类型)
      value: "",  // 初始值
      observer: function(newVal, oldVal, changePath) {
        // 修改的时候会触发 也可以写在methods中的 _propertyChange函数
      }
    }
  }
})
```

* data
* [ ] 其他

### 组件生命周期 [官网](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)
在lifetimes里面进行声明
* created
刚被创建好。 此时还不能调用setData, 通常值用于给组件this添加一些自定义属性的字段
* attached
this.data已经被赋值，大部分初始化应该这个时候进行
然而attached的时候，properties并没有赋值，导致这时候的仍然没有办法更新数据。
还是需要在observer里面完成。
* ready
组件在视图层布局完成后执行
* moved
组件实例被移动到节点树另一个位置
* detached
退出一个页面，如果组件还在节点树里面，detached会被触发
* error
组件抛出错误时执行

#### pageLifetimes
页面事件触发组件的事件
* show
* hide
* resize

### 其他
* [ ] [构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html)
    * 事件
        * created: 创建好了，这时候不能使用setData
        * attached: 加载好了，这时候可以用直接输入的那些数据，innertype="create", 这个变量可以用了
        * ready: 组件布局完成，这时候可以用onload里面生成然后传入组建的数据, innerid="{{resource.id}}", 这个变量可以用了
* [ ] 事件
    * 组件.js
    ```
    var myEventDetail = {'mydetail': 'mydetail'}
    var myEventOption = {'myoption': 'myoption'}
    this.triggerEvent('sing', myEventDetail, myEventOption);
    ```
    * 触发的选项
        * bubbles: 是否冒泡(false)
        * [ ] composed: 是否穿越组件(false)
        * [ ] capturePhase: 是否拥有捕获阶段(false)
